#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use ThriftTest::Types;


# HELPER FUNCTIONS AND STRUCTURES

package ThriftTest::ThriftTest_testVoid_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testVoid_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testVoid_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testVoid_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testString_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBool_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBool_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBool_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBool_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::BOOL, 1);
    $xfer += $output->writeBool($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBool_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBool_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBool_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBool_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::BYTE, 1);
    $xfer += $output->writeByte($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testByte_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testByte_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testByte_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testByte_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BYTE, 0);
    $xfer += $output->writeByte($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI32_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI32_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI32_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI32_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testI64_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testI64_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testI64_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testI64_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testDouble_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testDouble_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testDouble_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testDouble_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::DOUBLE, 0);
    $xfer += $output->writeDouble($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBinary_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBinary_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBinary_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBinary_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testBinary_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testBinary_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testBinary_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testBinary_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{thing} = ThriftTest::Xtruct->new();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStruct_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStruct_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStruct_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStruct_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{thing} = ThriftTest::Xtruct2->new();
        $xfer += $self->{thing}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::STRUCT, 1);
    $xfer += $self->{thing}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testNest_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testNest_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testNest_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct2->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testNest_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size263 = 0;
          $self->{thing} = {};
          my $_ktype264 = 0;
          my $_vtype265 = 0;
          $xfer += $input->readMapBegin(\$_ktype264, \$_vtype265, \$_size263);
          for (my $_i267 = 0; $_i267 < $_size263; ++$_i267)
          {
            my $key268 = 0;
            my $val269 = 0;
            $xfer += $input->readI32(\$key268);
            $xfer += $input->readI32(\$val269);
            $self->{thing}->{$key268} = $val269;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter270,$viter271) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeI32($kiter270);
          $xfer += $output->writeI32($viter271);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size272 = 0;
          $self->{success} = {};
          my $_ktype273 = 0;
          my $_vtype274 = 0;
          $xfer += $input->readMapBegin(\$_ktype273, \$_vtype274, \$_size272);
          for (my $_i276 = 0; $_i276 < $_size272; ++$_i276)
          {
            my $key277 = 0;
            my $val278 = 0;
            $xfer += $input->readI32(\$key277);
            $xfer += $input->readI32(\$val278);
            $self->{success}->{$key277} = $val278;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter279,$viter280) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter279);
          $xfer += $output->writeI32($viter280);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size281 = 0;
          $self->{thing} = {};
          my $_ktype282 = 0;
          my $_vtype283 = 0;
          $xfer += $input->readMapBegin(\$_ktype282, \$_vtype283, \$_size281);
          for (my $_i285 = 0; $_i285 < $_size281; ++$_i285)
          {
            my $key286 = '';
            my $val287 = '';
            $xfer += $input->readString(\$key286);
            $xfer += $input->readString(\$val287);
            $self->{thing}->{$key286} = $val287;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{thing}}));
      {
        while( my ($kiter288,$viter289) = each %{$self->{thing}}) 
        {
          $xfer += $output->writeString($kiter288);
          $xfer += $output->writeString($viter289);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testStringMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testStringMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testStringMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size290 = 0;
          $self->{success} = {};
          my $_ktype291 = 0;
          my $_vtype292 = 0;
          $xfer += $input->readMapBegin(\$_ktype291, \$_vtype292, \$_size290);
          for (my $_i294 = 0; $_i294 < $_size290; ++$_i294)
          {
            my $key295 = '';
            my $val296 = '';
            $xfer += $input->readString(\$key295);
            $xfer += $input->readString(\$val296);
            $self->{success}->{$key295} = $val296;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testStringMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter297,$viter298) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter297);
          $xfer += $output->writeString($viter298);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size299 = 0;
          $self->{thing} = {};
          my $_etype302 = 0;
          $xfer += $input->readSetBegin(\$_etype302, \$_size299);
          for (my $_i303 = 0; $_i303 < $_size299; ++$_i303)
          {
            my $elem304 = undef;
            $xfer += $input->readI32(\$elem304);
            $self->{thing}->{$elem304} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter305 (@{$self->{thing}})
        {
          $xfer += $output->writeI32($iter305);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testSet_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testSet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testSet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::SET) {
        {
          my $_size306 = 0;
          $self->{success} = {};
          my $_etype309 = 0;
          $xfer += $input->readSetBegin(\$_etype309, \$_size306);
          for (my $_i310 = 0; $_i310 < $_size306; ++$_i310)
          {
            my $elem311 = undef;
            $xfer += $input->readI32(\$elem311);
            $self->{success}->{$elem311} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testSet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::SET, 0);
    {
      $xfer += $output->writeSetBegin(Thrift::TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter312 (@{$self->{success}})
        {
          $xfer += $output->writeI32($iter312);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size313 = 0;
          $self->{thing} = [];
          my $_etype316 = 0;
          $xfer += $input->readListBegin(\$_etype316, \$_size313);
          for (my $_i317 = 0; $_i317 < $_size313; ++$_i317)
          {
            my $elem318 = undef;
            $xfer += $input->readI32(\$elem318);
            push(@{$self->{thing}},$elem318);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{thing}}));
      {
        foreach my $iter319 (@{$self->{thing}}) 
        {
          $xfer += $output->writeI32($iter319);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testList_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size320 = 0;
          $self->{success} = [];
          my $_etype323 = 0;
          $xfer += $input->readListBegin(\$_etype323, \$_size320);
          for (my $_i324 = 0; $_i324 < $_size320; ++$_i324)
          {
            my $elem325 = undef;
            $xfer += $input->readI32(\$elem325);
            push(@{$self->{success}},$elem325);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::I32, scalar(@{$self->{success}}));
      {
        foreach my $iter326 (@{$self->{success}}) 
        {
          $xfer += $output->writeI32($iter326);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testEnum_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testEnum_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testEnum_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testEnum_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_args->mk_accessors( qw( thing ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{thing} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{thing}) {
      $self->{thing} = $vals->{thing};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{thing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_args');
  if (defined $self->{thing}) {
    $xfer += $output->writeFieldBegin('thing', Thrift::TType::I64, 1);
    $xfer += $output->writeI64($self->{thing});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testTypedef_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testTypedef_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testTypedef_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testTypedef_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_args->mk_accessors( qw( hello ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hello} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hello}) {
      $self->{hello} = $vals->{hello};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{hello});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_args');
  if (defined $self->{hello}) {
    $xfer += $output->writeFieldBegin('hello', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{hello});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMapMap_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMapMap_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMapMap_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size327 = 0;
          $self->{success} = {};
          my $_ktype328 = 0;
          my $_vtype329 = 0;
          $xfer += $input->readMapBegin(\$_ktype328, \$_vtype329, \$_size327);
          for (my $_i331 = 0; $_i331 < $_size327; ++$_i331)
          {
            my $key332 = 0;
            my $val333 = [];
            $xfer += $input->readI32(\$key332);
            {
              my $_size334 = 0;
              $val333 = {};
              my $_ktype335 = 0;
              my $_vtype336 = 0;
              $xfer += $input->readMapBegin(\$_ktype335, \$_vtype336, \$_size334);
              for (my $_i338 = 0; $_i338 < $_size334; ++$_i338)
              {
                my $key339 = 0;
                my $val340 = 0;
                $xfer += $input->readI32(\$key339);
                $xfer += $input->readI32(\$val340);
                $val333->{$key339} = $val340;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key332} = $val333;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMapMap_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter341,$viter342) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI32($kiter341);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::I32, scalar(keys %{${viter342}}));
            {
              while( my ($kiter343,$viter344) = each %{${viter342}}) 
              {
                $xfer += $output->writeI32($kiter343);
                $xfer += $output->writeI32($viter344);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_args->mk_accessors( qw( argument ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{argument} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{argument}) {
      $self->{argument} = $vals->{argument};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{argument} = ThriftTest::Insanity->new();
        $xfer += $self->{argument}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_args');
  if (defined $self->{argument}) {
    $xfer += $output->writeFieldBegin('argument', Thrift::TType::STRUCT, 1);
    $xfer += $self->{argument}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testInsanity_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testInsanity_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testInsanity_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size345 = 0;
          $self->{success} = {};
          my $_ktype346 = 0;
          my $_vtype347 = 0;
          $xfer += $input->readMapBegin(\$_ktype346, \$_vtype347, \$_size345);
          for (my $_i349 = 0; $_i349 < $_size345; ++$_i349)
          {
            my $key350 = 0;
            my $val351 = [];
            $xfer += $input->readI64(\$key350);
            {
              my $_size352 = 0;
              $val351 = {};
              my $_ktype353 = 0;
              my $_vtype354 = 0;
              $xfer += $input->readMapBegin(\$_ktype353, \$_vtype354, \$_size352);
              for (my $_i356 = 0; $_i356 < $_size352; ++$_i356)
              {
                my $key357 = 0;
                my $val358 = new ThriftTest::Insanity();
                $xfer += $input->readI32(\$key357);
                $val358 = ThriftTest::Insanity->new();
                $xfer += $val358->read($input);
                $val351->{$key357} = $val358;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key350} = $val351;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testInsanity_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I64, Thrift::TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter359,$viter360) = each %{$self->{success}}) 
        {
          $xfer += $output->writeI64($kiter359);
          {
            $xfer += $output->writeMapBegin(Thrift::TType::I32, Thrift::TType::STRUCT, scalar(keys %{${viter360}}));
            {
              while( my ($kiter361,$viter362) = each %{${viter360}}) 
              {
                $xfer += $output->writeI32($kiter361);
                $xfer += ${viter362}->write($output);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_args->mk_accessors( qw( arg0 arg1 arg2 arg3 arg4 arg5 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  $self->{arg2} = undef;
  $self->{arg3} = undef;
  $self->{arg4} = undef;
  $self->{arg5} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
    if (defined $vals->{arg2}) {
      $self->{arg2} = $vals->{arg2};
    }
    if (defined $vals->{arg3}) {
      $self->{arg3} = $vals->{arg3};
    }
    if (defined $vals->{arg4}) {
      $self->{arg4} = $vals->{arg4};
    }
    if (defined $vals->{arg5}) {
      $self->{arg5} = $vals->{arg5};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::BYTE) {
        $xfer += $input->readByte(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{arg2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size363 = 0;
          $self->{arg3} = {};
          my $_ktype364 = 0;
          my $_vtype365 = 0;
          $xfer += $input->readMapBegin(\$_ktype364, \$_vtype365, \$_size363);
          for (my $_i367 = 0; $_i367 < $_size363; ++$_i367)
          {
            my $key368 = 0;
            my $val369 = '';
            $xfer += $input->readI16(\$key368);
            $xfer += $input->readString(\$val369);
            $self->{arg3}->{$key368} = $val369;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{arg4});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{arg5});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', Thrift::TType::BYTE, 1);
    $xfer += $output->writeByte($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg2}) {
    $xfer += $output->writeFieldBegin('arg2', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{arg2});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg3}) {
    $xfer += $output->writeFieldBegin('arg3', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::I16, Thrift::TType::STRING, scalar(keys %{$self->{arg3}}));
      {
        while( my ($kiter370,$viter371) = each %{$self->{arg3}}) 
        {
          $xfer += $output->writeI16($kiter370);
          $xfer += $output->writeString($viter371);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg4}) {
    $xfer += $output->writeFieldBegin('arg4', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{arg4});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg5}) {
    $xfer += $output->writeFieldBegin('arg5', Thrift::TType::I64, 6);
    $xfer += $output->writeI64($self->{arg5});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMulti_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMulti_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMulti_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMulti_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_args->mk_accessors( qw( arg ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg}) {
      $self->{arg} = $vals->{arg};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_args');
  if (defined $self->{arg}) {
    $xfer += $output->writeFieldBegin('arg', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{arg});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testException_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{err1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err1} = ThriftTest::Xception->new();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testException_result');
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', Thrift::TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_args->mk_accessors( qw( arg0 arg1 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arg0} = undef;
  $self->{arg1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arg0}) {
      $self->{arg0} = $vals->{arg0};
    }
    if (defined $vals->{arg1}) {
      $self->{arg1} = $vals->{arg1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{arg1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_args');
  if (defined $self->{arg0}) {
    $xfer += $output->writeFieldBegin('arg0', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{arg0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arg1}) {
    $xfer += $output->writeFieldBegin('arg1', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{arg1});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testMultiException_result;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testMultiException_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{err1} = undef;
  $self->{err2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{err1}) {
      $self->{err1} = $vals->{err1};
    }
    if (defined $vals->{err2}) {
      $self->{err2} = $vals->{err2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testMultiException_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = ThriftTest::Xtruct->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err1} = ThriftTest::Xception->new();
        $xfer += $self->{err1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{err2} = ThriftTest::Xception2->new();
        $xfer += $self->{err2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testMultiException_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err1}) {
    $xfer += $output->writeFieldBegin('err1', Thrift::TType::STRUCT, 1);
    $xfer += $self->{err1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{err2}) {
    $xfer += $output->writeFieldBegin('err2', Thrift::TType::STRUCT, 2);
    $xfer += $self->{err2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_args;
use base qw(Class::Accessor);
ThriftTest::ThriftTest_testOneway_args->mk_accessors( qw( secondsToSleep ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{secondsToSleep} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{secondsToSleep}) {
      $self->{secondsToSleep} = $vals->{secondsToSleep};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{secondsToSleep});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_args');
  if (defined $self->{secondsToSleep}) {
    $xfer += $output->writeFieldBegin('secondsToSleep', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{secondsToSleep});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTest_testOneway_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftTest_testOneway_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftTest_testOneway_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftTest::ThriftTestIf;

use strict;


sub testVoid{
  my $self = shift;

  die 'implement interface';
}

sub testString{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testBool{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testByte{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI32{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testI64{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testDouble{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testBinary{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStruct{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testNest{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testStringMap{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testSet{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testList{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testEnum{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testTypedef{
  my $self = shift;
  my $thing = shift;

  die 'implement interface';
}

sub testMapMap{
  my $self = shift;
  my $hello = shift;

  die 'implement interface';
}

sub testInsanity{
  my $self = shift;
  my $argument = shift;

  die 'implement interface';
}

sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  die 'implement interface';
}

sub testException{
  my $self = shift;
  my $arg = shift;

  die 'implement interface';
}

sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  die 'implement interface';
}

sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  die 'implement interface';
}

package ThriftTest::ThriftTestRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub testVoid{
  my ($self, $request) = @_;

  return $self->{impl}->testVoid();
}

sub testString{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testString($thing);
}

sub testBool{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testBool($thing);
}

sub testByte{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testByte($thing);
}

sub testI32{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI32($thing);
}

sub testI64{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testI64($thing);
}

sub testDouble{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testDouble($thing);
}

sub testBinary{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testBinary($thing);
}

sub testStruct{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStruct($thing);
}

sub testNest{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testNest($thing);
}

sub testMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testMap($thing);
}

sub testStringMap{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testStringMap($thing);
}

sub testSet{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testSet($thing);
}

sub testList{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testList($thing);
}

sub testEnum{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testEnum($thing);
}

sub testTypedef{
  my ($self, $request) = @_;

  my $thing = ($request->{'thing'}) ? $request->{'thing'} : undef;
  return $self->{impl}->testTypedef($thing);
}

sub testMapMap{
  my ($self, $request) = @_;

  my $hello = ($request->{'hello'}) ? $request->{'hello'} : undef;
  return $self->{impl}->testMapMap($hello);
}

sub testInsanity{
  my ($self, $request) = @_;

  my $argument = ($request->{'argument'}) ? $request->{'argument'} : undef;
  return $self->{impl}->testInsanity($argument);
}

sub testMulti{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  my $arg2 = ($request->{'arg2'}) ? $request->{'arg2'} : undef;
  my $arg3 = ($request->{'arg3'}) ? $request->{'arg3'} : undef;
  my $arg4 = ($request->{'arg4'}) ? $request->{'arg4'} : undef;
  my $arg5 = ($request->{'arg5'}) ? $request->{'arg5'} : undef;
  return $self->{impl}->testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
}

sub testException{
  my ($self, $request) = @_;

  my $arg = ($request->{'arg'}) ? $request->{'arg'} : undef;
  return $self->{impl}->testException($arg);
}

sub testMultiException{
  my ($self, $request) = @_;

  my $arg0 = ($request->{'arg0'}) ? $request->{'arg0'} : undef;
  my $arg1 = ($request->{'arg1'}) ? $request->{'arg1'} : undef;
  return $self->{impl}->testMultiException($arg0, $arg1);
}

sub testOneway{
  my ($self, $request) = @_;

  my $secondsToSleep = ($request->{'secondsToSleep'}) ? $request->{'secondsToSleep'} : undef;
  return $self->{impl}->testOneway($secondsToSleep);
}

package ThriftTest::ThriftTestClient;


use base qw(ThriftTest::ThriftTestIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub testVoid{
  my $self = shift;

    $self->send_testVoid();
  $self->recv_testVoid();
}

sub send_testVoid{
  my $self = shift;

  $self->{output}->writeMessageBegin('testVoid', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testVoid_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testVoid{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testVoid_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub testString{
  my $self = shift;
  my $thing = shift;

    $self->send_testString($thing);
  return $self->recv_testString();
}

sub send_testString{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testString', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testString_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testString_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testString failed: unknown result";
}
sub testBool{
  my $self = shift;
  my $thing = shift;

    $self->send_testBool($thing);
  return $self->recv_testBool();
}

sub send_testBool{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testBool', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testBool_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testBool{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testBool_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testBool failed: unknown result";
}
sub testByte{
  my $self = shift;
  my $thing = shift;

    $self->send_testByte($thing);
  return $self->recv_testByte();
}

sub send_testByte{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testByte', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testByte_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testByte{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testByte_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testByte failed: unknown result";
}
sub testI32{
  my $self = shift;
  my $thing = shift;

    $self->send_testI32($thing);
  return $self->recv_testI32();
}

sub send_testI32{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI32', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testI32_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI32{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testI32_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI32 failed: unknown result";
}
sub testI64{
  my $self = shift;
  my $thing = shift;

    $self->send_testI64($thing);
  return $self->recv_testI64();
}

sub send_testI64{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testI64', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testI64_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testI64{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testI64_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testI64 failed: unknown result";
}
sub testDouble{
  my $self = shift;
  my $thing = shift;

    $self->send_testDouble($thing);
  return $self->recv_testDouble();
}

sub send_testDouble{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testDouble', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testDouble_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testDouble{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testDouble_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testDouble failed: unknown result";
}
sub testBinary{
  my $self = shift;
  my $thing = shift;

    $self->send_testBinary($thing);
  return $self->recv_testBinary();
}

sub send_testBinary{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testBinary', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testBinary_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testBinary{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testBinary_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testBinary failed: unknown result";
}
sub testStruct{
  my $self = shift;
  my $thing = shift;

    $self->send_testStruct($thing);
  return $self->recv_testStruct();
}

sub send_testStruct{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStruct', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testStruct_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStruct{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testStruct_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStruct failed: unknown result";
}
sub testNest{
  my $self = shift;
  my $thing = shift;

    $self->send_testNest($thing);
  return $self->recv_testNest();
}

sub send_testNest{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testNest', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testNest_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testNest{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testNest_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testNest failed: unknown result";
}
sub testMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testMap($thing);
  return $self->recv_testMap();
}

sub send_testMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMap_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMap failed: unknown result";
}
sub testStringMap{
  my $self = shift;
  my $thing = shift;

    $self->send_testStringMap($thing);
  return $self->recv_testStringMap();
}

sub send_testStringMap{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testStringMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testStringMap_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testStringMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testStringMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testStringMap failed: unknown result";
}
sub testSet{
  my $self = shift;
  my $thing = shift;

    $self->send_testSet($thing);
  return $self->recv_testSet();
}

sub send_testSet{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testSet', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testSet_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testSet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testSet_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testSet failed: unknown result";
}
sub testList{
  my $self = shift;
  my $thing = shift;

    $self->send_testList($thing);
  return $self->recv_testList();
}

sub send_testList{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testList', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testList_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testList failed: unknown result";
}
sub testEnum{
  my $self = shift;
  my $thing = shift;

    $self->send_testEnum($thing);
  return $self->recv_testEnum();
}

sub send_testEnum{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testEnum', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testEnum_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testEnum{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testEnum_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testEnum failed: unknown result";
}
sub testTypedef{
  my $self = shift;
  my $thing = shift;

    $self->send_testTypedef($thing);
  return $self->recv_testTypedef();
}

sub send_testTypedef{
  my $self = shift;
  my $thing = shift;

  $self->{output}->writeMessageBegin('testTypedef', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testTypedef_args();
  $args->{thing} = $thing;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testTypedef{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testTypedef_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testTypedef failed: unknown result";
}
sub testMapMap{
  my $self = shift;
  my $hello = shift;

    $self->send_testMapMap($hello);
  return $self->recv_testMapMap();
}

sub send_testMapMap{
  my $self = shift;
  my $hello = shift;

  $self->{output}->writeMessageBegin('testMapMap', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMapMap_args();
  $args->{hello} = $hello;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMapMap{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMapMap_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMapMap failed: unknown result";
}
sub testInsanity{
  my $self = shift;
  my $argument = shift;

    $self->send_testInsanity($argument);
  return $self->recv_testInsanity();
}

sub send_testInsanity{
  my $self = shift;
  my $argument = shift;

  $self->{output}->writeMessageBegin('testInsanity', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testInsanity_args();
  $args->{argument} = $argument;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testInsanity{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testInsanity_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testInsanity failed: unknown result";
}
sub testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

    $self->send_testMulti($arg0, $arg1, $arg2, $arg3, $arg4, $arg5);
  return $self->recv_testMulti();
}

sub send_testMulti{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;
  my $arg2 = shift;
  my $arg3 = shift;
  my $arg4 = shift;
  my $arg5 = shift;

  $self->{output}->writeMessageBegin('testMulti', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMulti_args();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->{arg2} = $arg2;
  $args->{arg3} = $arg3;
  $args->{arg4} = $arg4;
  $args->{arg5} = $arg5;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMulti{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMulti_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "testMulti failed: unknown result";
}
sub testException{
  my $self = shift;
  my $arg = shift;

    $self->send_testException($arg);
  $self->recv_testException();
}

sub send_testException{
  my $self = shift;
  my $arg = shift;

  $self->{output}->writeMessageBegin('testException', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testException_args();
  $args->{arg} = $arg;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testException_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{err1}) {
    die $result->{err1};
  }
  return;
}
sub testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

    $self->send_testMultiException($arg0, $arg1);
  return $self->recv_testMultiException();
}

sub send_testMultiException{
  my $self = shift;
  my $arg0 = shift;
  my $arg1 = shift;

  $self->{output}->writeMessageBegin('testMultiException', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testMultiException_args();
  $args->{arg0} = $arg0;
  $args->{arg1} = $arg1;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_testMultiException{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = new Thrift::TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftTest::ThriftTest_testMultiException_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{err1}) {
    die $result->{err1};
  }
  if (defined $result->{err2}) {
    die $result->{err2};
  }
  die "testMultiException failed: unknown result";
}
sub testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

    $self->send_testOneway($secondsToSleep);
}

sub send_testOneway{
  my $self = shift;
  my $secondsToSleep = shift;

  $self->{output}->writeMessageBegin('testOneway', Thrift::TMessageType::ONEWAY, $self->{seqid});
  my $args = new ThriftTest::ThriftTest_testOneway_args();
  $args->{secondsToSleep} = $secondsToSleep;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
package ThriftTest::ThriftTestProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = new Thrift::TApplicationException('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_testVoid {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testVoid_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testVoid_result();
    $self->{handler}->testVoid();
    $output->writeMessageBegin('testVoid', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testString_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testString_result();
    $result->{success} = $self->{handler}->testString($args->thing);
    $output->writeMessageBegin('testString', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testBool {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testBool_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testBool_result();
    $result->{success} = $self->{handler}->testBool($args->thing);
    $output->writeMessageBegin('testBool', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testByte {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testByte_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testByte_result();
    $result->{success} = $self->{handler}->testByte($args->thing);
    $output->writeMessageBegin('testByte', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI32 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testI32_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testI32_result();
    $result->{success} = $self->{handler}->testI32($args->thing);
    $output->writeMessageBegin('testI32', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testI64 {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testI64_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testI64_result();
    $result->{success} = $self->{handler}->testI64($args->thing);
    $output->writeMessageBegin('testI64', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testDouble {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testDouble_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testDouble_result();
    $result->{success} = $self->{handler}->testDouble($args->thing);
    $output->writeMessageBegin('testDouble', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testBinary {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testBinary_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testBinary_result();
    $result->{success} = $self->{handler}->testBinary($args->thing);
    $output->writeMessageBegin('testBinary', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStruct {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testStruct_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testStruct_result();
    $result->{success} = $self->{handler}->testStruct($args->thing);
    $output->writeMessageBegin('testStruct', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testNest {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testNest_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testNest_result();
    $result->{success} = $self->{handler}->testNest($args->thing);
    $output->writeMessageBegin('testNest', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMap_result();
    $result->{success} = $self->{handler}->testMap($args->thing);
    $output->writeMessageBegin('testMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testStringMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testStringMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testStringMap_result();
    $result->{success} = $self->{handler}->testStringMap($args->thing);
    $output->writeMessageBegin('testStringMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testSet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testSet_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testSet_result();
    $result->{success} = $self->{handler}->testSet($args->thing);
    $output->writeMessageBegin('testSet', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testList_result();
    $result->{success} = $self->{handler}->testList($args->thing);
    $output->writeMessageBegin('testList', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testEnum {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testEnum_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testEnum_result();
    $result->{success} = $self->{handler}->testEnum($args->thing);
    $output->writeMessageBegin('testEnum', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testTypedef {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testTypedef_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testTypedef_result();
    $result->{success} = $self->{handler}->testTypedef($args->thing);
    $output->writeMessageBegin('testTypedef', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMapMap {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMapMap_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMapMap_result();
    $result->{success} = $self->{handler}->testMapMap($args->hello);
    $output->writeMessageBegin('testMapMap', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testInsanity {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testInsanity_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testInsanity_result();
    $result->{success} = $self->{handler}->testInsanity($args->argument);
    $output->writeMessageBegin('testInsanity', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMulti {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMulti_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMulti_result();
    $result->{success} = $self->{handler}->testMulti($args->arg0, $args->arg1, $args->arg2, $args->arg3, $args->arg4, $args->arg5);
    $output->writeMessageBegin('testMulti', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testException_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testException_result();
    eval {
      $self->{handler}->testException($args->arg);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('testException', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('testException', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testMultiException {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testMultiException_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftTest::ThriftTest_testMultiException_result();
    eval {
      $result->{success} = $self->{handler}->testMultiException($args->arg0, $args->arg1);
    }; if( UNIVERSAL::isa($@,'ThriftTest::Xception') ){ 
      $result->{err1} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'ThriftTest::Xception2') ){ 
      $result->{err2} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = new Thrift::TApplicationException("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('testMultiException', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('testMultiException', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_testOneway {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftTest::ThriftTest_testOneway_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->testOneway($args->secondsToSleep);
    return;
}
1;
